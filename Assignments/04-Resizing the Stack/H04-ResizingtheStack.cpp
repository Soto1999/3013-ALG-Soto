///////////////////////////////////////////////////////////////////////////////
//
// Author:           Jose Soto
// Email:            josesoto56@icloud.com
// Label:            H04
// Title:            Homework 04 - Resizing the Stack
// Course:           3013
// Semester:         Spring 2020
//
// Description:
//       Array based stack that will push evens onto the stack and odds off of
//		 the stack. The stack will increase and decrease depending on how filled
//		 the stack actually is.
//
/////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
using namespace std;

/**
 * ArrayStack
 *
 * Description:
 *      Array based stack
 *
 * Public Methods:
 *      - See class below
 *
 * Usage:
 *      - See main program
 *
 */
class ArrayStack {
private:
	int* A;           // pointer to array of int's
	int size;         // current max stack size
	int top;          // top of stack
	int maxSize;      // max size generated by stack
	int resizeCounter;// how many times the stack size chnaged
	int actualSize;	  // how many elements are in the stack
public:
	/**
	 * ArrayStack
	 *
	 * Description:
	 *      Constructor no params
	 *
	 * Params:
	 *     - None
	 *
	 * Returns:
	 *     - NULL
	 */
	ArrayStack() {
		size = 10;
		A = new int[size];
		top = -1;
		maxSize = 10;
		actualSize = 0;
		resizeCounter = 0;
	}

	/**
	 * ArrayStack
	 *
	 * Description:
	 *      Constructor size param
	 *
	 * Params:
	 *     - int size
	 *
	 * Returns:
	 *     - NULL
	 */
	ArrayStack(int s) {
		size = s;
		A = new int[s];
		top = -1;
		maxSize = s;
		actualSize = 0;
		resizeCounter = 0;
	}

	/**
	 * Public bool: Empty
	 *
	 * Description:
	 *      Stack empty?
	 *
	 * Params:
	 *      NULL
	 *
	 * Returns:
	 *      [bool] true = empty
	 */
	bool Empty() {
		return (top <= -1);
	}

	/**
	 * Public bool: Full
	 *
	 * Description:
	 *      Stack full?
	 *
	 * Params:
	 *      NULL
	 *
	 * Returns:
	 *      [bool] true = full
	 */
	bool Full() {
		return (top >= size - 1);
	}

	/**
	 * Public int: Peek
	 *
	 * Description:
	 *      Returns top value without altering the stack
	 *
	 * Params:
	 *      NULL
	 *
	 * Returns:
	 *      [int] top value if any
	 */
	int Peek() {
		if (!Empty()) {
			return A[top];
		}

		return -99; // some sentinel value
					// not a good solution
	}

	/**
	 * Public int: Pop
	 *
	 * Description:
	 *      Returns top value and removes it from stack
	 *
	 * Params:
	 *      NULL
	 *
	 * Returns:
	 *      [int] top value if any
	 */
	int Pop() {
		if (!Empty()) {
			actualSize--;
			if (actualSize * 2 < size && actualSize > 10) {
				ContainerShrink();
			}
			return A[top--];
		}

		return -99; // some sentinel value
					// not a good solution

	}

	/**
	 * Public void: Print
	 *
	 * Description:
	 *      Prints stack to standard out
	 *
	 * Params:
	 *      NULL
	 *
	 * Returns:
	 *      NULL
	 */
	void Print() {
		for (int i = 0; i <= top; i++) {
			cout << A[i] << " ";
		}
		cout << endl;
	}

	/**
	 * Public bool: Push
	 *
	 * Description:
	 *      Adds an item to top of stack
	 *
	 * Params:
	 *      [int] : item to be added
	 *
	 * Returns:
	 *      [bool] ; success = true
	 */
	bool Push(int x) {
		if (Full()) {
			ContainerGrow();
		}
		if (!Full()) {
			A[++top] = x;
			actualSize++;
			return true;
		}

		return false;

	}

	/**
	 * Public void: ContainerGrow
	 *
	 * Description:
	 *      Resizes the container for the stack by doubling
	 *      its capacity
	 *
	 * Params:
	 *      NULL
	 *
	 * Returns:
	 *      NULL
	 */
	void ContainerGrow() {
		int newSize = size * 1.75;          // double size of original
		int* B = new int[newSize];          // allocate new memory

		for (int i = 0; i < size; i++) {    // copy values to new array
			B[i] = A[i];
		}

		if (newSize > maxSize) {    // checks to see if the stack
			maxSize = newSize;      // has reached a new max
		}

		delete[] A;                 // delete old array

		size = newSize;             // save new size

		A = B;                      // reset array pointer

		resizeCounter++;			// keeps track of number of resizes

	}

	/**
	 * Public void: ContainerShrink
	 *
	 * Description:
	 *      Resizes the container for the stack by halfing
	 *      its capacity
	 *
	 * Params:
	 *      NULL
	 *
	 * Returns:
	 *      NULL
	 */
	void ContainerShrink() {
		int newSize = size * .5;		      // half the size of original
		int* B = new int[newSize];	          // allocate new memory

		for (int i = 0; i < newSize; i++) {   // copy values to new array
			B[i] = A[i];
		}

		delete[] A;                 // delete old array

		size = newSize;             // save new size

		A = B;                      // reset array pointer

		resizeCounter++;			// keeps track of number of resizes
	}

	/**
	 * Public int: getActualSize
	 *
	 * Description:
	 *      Returns number of elements in stack
	 *
	 * Params:
	 *      NULL
	 *
	 * Returns:
	 *     [ int ] number of elements
	 */
	int getActualSize() {
		return actualSize;
	}

	/**
	 * Public int: getSize
	 *
	 * Description:
	 *      Returns stack capacity
	 *
	 * Params:
	 *      NULL
	 *
	 * Returns:
	 *     [ int ] capacity
	 */
	int getSize() {
		return size;
	}

	/**
	 * Public int: getMax
	 *
	 * Description:
	 *      Returns largest capacity achieved
	 *
	 * Params:
	 *      NULL
	 *
	 * Returns:
	 *     [ int ] largest capacity
	 */
	int getMax() {
		return maxSize;
	}

	/**
	 * Public int: getResizeCounter
	 *
	 * Description:
	 *      Returns number of stack resizes performed
	 *
	 * Params:
	 *      NULL
	 *
	 * Returns:
	 *     [ int ] number of resizes
	 */
	int getResizeCoutner() {
		return resizeCounter;
	}
};

// MAIN DRIVER
// Simple Array Based Stack Usage:
int main() {
	ArrayStack stack;		// instance of class
	ifstream infile;		// infile streaming variable
	ofstream outfile;		// outfile streaming variable
	int num;				// number to be read in

	infile.open("nums.dat");
	

	while (!infile.eof()) { // loop to read in values and push
		infile >> num;      // or pop
		if (num % 2 == 0)
			stack.Push(num);
		else {
			stack.Pop();
		}
	}

	cout << "###################################"
		"###################################\n";

	cout << "Assignment 4 - Resizing Stack\n";
	cout << "CMPS 3013\n";
	cout << "Jose Soto\n\n";

	cout << "Max stack size: " << stack.getMax() << "\n";
	cout << "End Stack size: " << stack.getSize() << "\n";
	cout << "Stack resized: " << stack.getResizeCoutner() << " times\n";

	cout << "###################################"
		"###################################\n";
	system("pause");
	return 0;
}